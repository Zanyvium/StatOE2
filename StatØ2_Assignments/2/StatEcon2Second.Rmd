---
title: "Stat Econ 2 Second"
author: "Victor Z. Nygaard"
header-includes:
   - \usepackage[utf8]{inputenc}
   - \usepackage{verbatim}
   - \usepackage[language]{babel}
   - \usepackage[encoding]{inputenc}
   - \usepackage{hyperref}
   - \usepackage{amsmath}
   - \usepackage{mathtools}
   - \usepackage{amssymb}
   - \usepackage{mathtools}
   - \usepackage{nicefrac}
   - \usepackage{fullpage}
   - \usepackage{stmaryrd}
   - \usepackage{aligned-overset}
   - \usepackage{pdfpages}
date: "Last compiled on `r format(Sys.time(), '%d. %B, %Y')`"
# Hvordan får  vi den til at printe February i stedet for februar??????
output: html_document
---

------------------------------------------------------------------------

```{=html}
<!-- RMD tips:
1. CTRL+SHIFT+C RMD-comments-out the selected lines, with in a standard HTML comment-out format. 

2. CTRL+ALT+I inserts a new r codechunck

3. Pressing CTRL+SHIFT+ENTER when over a code chunck gives you a preview of the results of the chunck

4. CTRL+SHIFT+K gives you a preview of the entire resulting HTML file.

5. Note the different results of '#HS 1' and 
'# HS 1' (without the '') in the output

6. It is possible to compile regular R-scripts into Rmd files - this is done by pressing CTRL+SHIFT+K while attending any R-script. <<<- Though this apparently doesn't work for HS Problems.R for some reason!?!?!? ->>>

7. Selective use of the echo=c(...) option within code chuncks allows assignment of a variable, to show the assignment in the knitted document, and showing the value of the assignment seamlessly as well - see HS2.3

8. It is possible to include results of R-analysis such as summary statistics in LaTeX-equations in RMD, see HS2.3

9. Adding fig.align="center" to a code chunk centers any figures generated by the chunck.

9.1 note that properties of codechunks seem casesensitive; fig.align="center" centers a figure, but fig.align="Center" (with capital C) doesn't

10. A new subtitle needs a blank line before itself: 
'works:

#### HS 7
'

'doesn't:
blablabla
#### HS 7
'

'doesn't either:
<!-- blablabla ->
#### HS 7
'
11. Pressing F7 when marking, or hovering over a word will spellcheck the word

12. CTRL + - (minus) zooms out, CTRL + + (plus) zooms in

13. CTRL + D Deletes the current line, or current selection of lines

14. THE FOLLOWING SOURCE EDITOR FOLDING METHODS:
14.1 Collapse current fold: ALT + L
14.1.1: Expand current fold: SHIFT + ALT + L
14.2 Collapse "all" subfolds: ALT + O <- !?!! Note that this leaves a small letter 'o' in the text !!?!
14.2.1 Expand "all" subfolds: SHIFT + ALT + O
14.3 Collapse all other folds: ALT + 0 (zero)

15. SHIFT + ALT + J allows you to jump to specific parts of the document

16. Writing a new line with '...' will cause all previous output to be hidden in the knittet document

17. Writing (q<-5) around R code, will both assign and print the code upon assignment 

18. Note that 'attach' only has the scope of the current R-chunck.

19. One way to get pdf printout is to compile a html-printout, and then, in-browser, 'print' the HTML page as a pdf.

20. CTRL + SHIFT + M gives the pipe operator.

21. Pressing CTRL + F3 searches on the selected word.

22. CTRL
-->
```
<!-- ---?--- How do I create a closeable Rmd section, such that I do not have to scroll through the LaTeX commands each time? - !!! Can be done with '-----' through this also creates a line in the knittet document. -->

<!-- How do I publish and share the HTML as a viewable (and linkable) website - this can be done through github? -->

<!-- How can I share R markdown files such that multiple people can edit them at the same time? -->

<!-- Do we need parindent controls as in LaTeX? -->

<!-- Use of the cache function to reduce recompile times -->

<!-- How to close current subsection with a keyboard shortcut? How to close subsubsections,...? - !!!See RMD tip 14!!! -->

<!-- Chunk naming? -->

<!-- How to define variables such that they have scope within their own ## segment? -->

<!-- How do I delete all non-needed variables for each new section in R??? -->

<!-- LaTeX commands -->

\newcommand{\C}{\mathbb{C}} <!--- Komplekse tal --->

\newcommand{\R}{\mathbb{R}} <!--- Reelle tal--->

\newcommand{\Q}{\mathbb{Q}}

<!---Rationelle tal--->

\newcommand{\Z}{\mathbb{Z}}

<!---Hele tal--->

\newcommand{\N}{\mathbb{N}}

<!---Naturlige tal--->

\newcommand{\E}{\mathbb{E}}

<!---mean--->

\newcommand{\F}{\mathbb{F}}

<!---Baggrundsrum sigma-alg--->

\newcommand{\B}{\mathbb{B}}

<!---Borel sigma--->

\newcommand{\K}{\mathbb{K}}

<!---Generel field--->

\newcommand{\RB}{\overline{\R}}

<!---Udvidede reelle tal--->


\newcommand{\ms}[1]{\mathscr{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\BR}{\mathcal{B}\left(\R\right)} <!---Borel på Reelle tal -->
\newcommand{\BRB}{\mathcal{B}\left(\RB\right))} <!---Borel på udvidede reelle tal -->


\newcommand{\mf}[1]{\mathfrak{#1}} 
\newcommand{\mcG}[2]{\mathcal{#1}^1(#2)} 
\newcommand{\mcGG}[4]{\mathcal{#1}_{#3}^{#2}(#4)}
\newcommand{\GMR}{\left(X,\ms{A},\mu\right)} <!---Generelt målrum -->

\newcommand{\PBS}{\lrp{\Omega,\F, P}}

<!--- Probability background space -->

\newcommand{\RMR}{\left(\R,\BR, \lambda\right)}

<!---Reelt målrum, m. Borel, og lebesgue mål. -->

\newcommand{\MRBPBR}{\mc{M}_{\RB}^+\left(\BR\right)}

<!---Mængden af positive målelige funktioner som sender (R,BR) over i (RB, BRB) -->

\newcommand{\MRPBR}{\mc{M}_{\R}^+\left(\BR\right)}

<!---Mængden af positive målelige funktioner som sender (R,BR) over i (R, BR) -->

<!---L_p spaces on [0,1] with m -->


\newcommand{\Lp}[1]{L_{#1}\lrp{\lrs{0,1},m}} 
\newcommand{\mclxy}{\mc{L}\lrp{X,Y}}

<!---Bounded linear functionals from X to Y -->

\newcommand{\mckxy}{\mc{K}\lrp{X,Y}}

<!---Compact Bounded linear functionals from X to Y -->

\newcommand{\mssr}{\ms{S}(\R)}

<!---The Schwartz space on $\R$ -->

<!---Arrows -->

\newcommand{\ra}{\rightarrow} <!---Konvergens pil højre -->
\newcommand{\nra}{\nrightarrow} <!---ikke Konvergens pil højre -->
\newcommand{\la}{\leftarrow} <!---Konv pil venstre -->
\newcommand{\nla}{\nleftarrow} <!---ikke Konvergens pil venstre -->
\newcommand{\lra}{\leftrightarrow} <!---højre venstre pil -->
\newcommand{\nlra}{\nleftrightarrow} <!---ikke højre venstre pil -->
\newcommand{\hra}{\hookrightarrow} <!---Injektiv  pil højre -->
\newcommand{\Ra}{\Rightarrow} <!---Implikations pil højre -->
\newcommand{\Lra}{\Leftrightarrow} <!---Bi-implikations pil -->
\newcommand{\Uda}{\Updownarrow} <!---Bi-implikations pil (op og ned) -->
\newcommand{\Da}{\Downarrow} <!---implikations pil (ned) -->
\newcommand{\rhpu}{\rightharpoonup} <!---Weak convergence in Hilbert spaces -->
\newcommand{\raas}{\overset{\textit{a.s.}}{\ra}} <!---Konvergens a.s. pil højre -->
\newcommand{\rap}{\overset{\textit{P}}{\ra}} <!---Konvergens P pil højre -->
\newcommand{\rad}{\overset{\textit{d}}{\ra}} <!---Konvergens d. pil højre -->
\newcommand{\asympt}{\overset{\textit{as}}{\sim}} <!--- asymptotisk konvergens -->


<!-- Equalities -->
\newcommand{\eqtx}[1]{\overset{\text{#1}}{=}} <!-- Insert text above equality -->
\newcommand{\eqas}{\eqtx{a.s.}} <!-- a.s. equality -->
\newcommand{\inse}{\overset{\cdot}{=}} <!-- Inserting values for parameters -->
\newcommand{\eqd}{\overset{d.}{=}} <!-- Equality of distribution -->

<!-- LHS & RHS calculations -->

\newcommand{\swel}{\overset{\swarrow}{=}} <!---Continue calculation on left hand side with equality -->
\newcommand{\sweq}{\overset{\swarrow}{\equiv}} <!---Continue calculation on left hand side with equivalence -->
\newcommand{\seel}{\overset{\searrow}{=}} <!---Continue calculation on right hand side with equality -->
\newcommand{\seeq}{\overset{\searrow}{\equiv}} <!---Continue calculation on right hand side with equivalence -->
\newcommand{\inse}{\overset{\cdot}{=}} <!--- Insert values in calculation -->

\newcommand{\PMX}{\mc{P}\left(X\right)} <!---Potensmængde af X -->
\newcommand{\comp}{\mathsf{c}} <!---Set compliment -->
\newcommand{\sm}{\setminus} <!---mængdedifferens -->

<!--- Parenteser --->
\newcommand{\lrp}[1]{\mathopen{}\left({#1}\right)\mathclose{}} <!-- \left("STUFF"\right) -->
\newcommand{\lrc}[1]{\mathopen{}\left\{{#1}\right\}\mathclose{}} <!-- \left\{"STUFF"\right\} -->
\newcommand{\lrs}[1]{\mathopen{}\left[{#1}\right]\mathclose{}} <!-- \left["STUFF"\right] -->
\newcommand{\lrb}[1]{\mathopen{}\left|{#1}\right|\mathclose{}} <!-- \left|"STUFF"\right| -->
\newcommand{\inner}[2]{\mathopen{}\left\langle #1, #2 \right\rangle\mathclose{}}  <!-- <\left"STUFF1","STUFF2"\right> -->
\newcommand{\norm}[1]{\mathopen{}\left\lVert#1\right\rVert\mathclose{}} <!-- \left||"STUFF"\right|| -->
\newcommand{\floor}[1]{\lfloor #1 \rfloor} <!---Floor function --->
\newcommand{\ceil}[1]{\lceil #1 \rceil} <!---ceil --->
\newcommand{\FFou}[1]{\mc{F}(#1)} <!---Fourier Transform notation 1 --->
\newcommand{\Fou}[1]{\widehat{#1}} <!---Fourier Transform notation 2 --->

<!--- Farver --->
\newcommand{\blue}[1]{\textcolor{blue}{{#1}}} <!--- Turning text blue --->
\newcommand{\red}[1]{\textcolor{red}{{#1}}} <!--- Turning text red --->
\newcommand{\green}[1]{\textcolor{green}{{#1}}} <!--- Turning text green --->
\newcommand{\purple}[1]{\textcolor{purple}{{#1}}} <!--- Turning text purple --->
\newcommand{\cyan}[1]{\textcolor{cyan}{{#1}}} <!--- Turning text cyan --->
\newcommand{\orange}[1]{\textcolor{orange}{{#1}}} <!--- Turning text orange --->

<!--- Oversetting bold accents --->
\newcommand{\boldhat}[1]{\mathbf{\hat{\text{$#1$}}}}
\newcommand{\boldbar}[1]{\mathbf{\bar{\text{$#1$}}}}
\newcommand{\boldtilde}[1]{\mathbf{\tilde{\text{$#1$}}}}
\newcommand{\boldcheck}[1]{\mathbf{\check{\text{$#1$}}}}

\newcommand{\indep}{\perp \!\!\! \perp} <!---independence --->
\newcommand{\colvec}[1]{\begin{pmatrix}{#1}\end{pmatrix}} <!-- Begin column vector - Doesn't seem to work with non-column vectors...-->


\newcommand{\nd}[2]{\mc{N}\lrp{{#1},{#2}}} <!-- Normal distribution -->
\newcommand{\dnd}[2]{\sim\mc{N}\lrp{{#1},{#2}}} <!-- Distributed as Normal distribution -->

<!-- \newcommand{\Rlogo}{![](R_logo.png){#id .class width=auto height=16px} } <!-- R logo implemented in text -->

<!-- Image insertion alla LaTeX doesn't seem to work too well..., but inserting the above gives the desired effect. -->

<!--???? \declareMathOperator{\SE}{SE} DOESN'T REALLY SEEM TO WORK????-->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE) #semi-dangerous to set cache true globally :||
knitr::opts_chunk$set(fig.align = 'center')
library(tidyverse)
library(reshape2)
library(gridExtra)
library(xtable)
library(splines)
library(survival)
library(grid)
library(lubridate)
library(xts)
theme_set(theme_minimal())
library(MASS)
set.seed(314)
varnametotext <- function(v){
   deparse(substitute(v))
}
Stdresplot <- function(model, main = paste("(Estimate, Std. Res.)-plot of", deparse(substitute(model))), ylab ="Standardized residuals", ...) {
 fit <- fitted(model)
 rst <- rstandard(model)
 qplot(fit, rst, main = main, ylab = ylab, ylim = c(-max(3.2,max(abs(rst))), max(3.2,max(abs(rst)))) )+geom_hline(yintercept = 0) #Largest symmetric interval (around 0) of (-3.2,3.2) or (-largest absolute rst, largest absolute rst)
}
QQplotdraw <- function(model, main = paste("Normal QQ-plot of", deparse(substitute(model))), xlab = "Theoretical Quantiles", ylab ="Sample Quantiles", ...) {
   rst <- rstandard(model)
   #dataname <- getCall(lm_LT)$data
   ggplot(data = eval(getCall(model)$data), main = main, xlab = xlab, ylab = ylab) + geom_qq() + geom_qq_line() + aes(sample = rst)
} #main, xlab, ylab call do not work for some reason
StdresQQPlot <- function(model,...) {
   p1 <- Stdresplot(model,...)
   p2 <- QQplotdraw(model,...)
   #library(gridExtra)
   grid.arrange(p1,p2, ncol = 2)
}
```

# Stat Econ 2 Assignment 2

We may start off by setting seed:
```{r}
set.seed(314)
```

## Exercise 1

### a)

With $\hat{X}_{n+1}=E\lrp{X_{n+1}|X_n}=\phi X_n$ being the best approximation of $X_{n+1}$ in the sense mentioned, the surrogate predictor $\tilde{X}_{n+1}=\hat{\phi}X_n$ will necessarily be worse, as $\hat{\phi}$ will in and of itself is fallible to errors in predicting $\phi.$ It will thus not be the best approximation.

### b)

We will initialize, assuming a central student t distribution, and simulate the AR(1) model, with slope $0.9$
```{r}
n <- 1000
X <- 0:1000
Z <- rt(n+1,10)
for (i in 2:1001){
  X[i] <- 0.9*X[i-1]+Z[i]
}
```
With this we may start simulation of the YW estimates for later implementation in simulating the surrigate pridictor process, for this we reimplement functions build for the first assignment in StatØ2:
```{r}
gammaf <- function(X,h) {
   n <- length(X)
   gamt <- 0
   for (t in 1:(n-h)) {
      tempt <- (X[t]-mean(X))*(X[t+h]-mean(X)) 
      gamt <- gamt + tempt
   }
   1/n*gamt
}
```
Such that for
$$
\hat{\phi}_n=\frac{\gamma_{n,X}\lrp{1}}{\gamma_{n,X}\lrp{0}}\equiv\rho_{n,X}\lrp{1}
$$

we have
```{r}
phih <- 1:1000
for (i in phih) {
  phih[i] <- gammaf(X,i)
}
```

Calculating the surrogate predictor for indices $901$ through $1000$:
```{r}
Xt <- 901:1000
for (k in 901:1000) {
  Xt[k-900] <- phih[k-1]*X[k-1]
}
```

and plotting the `Xt` as the solid line, together with the dashed line of `X[901:1000]`:
```{r}
ts.plot(Xt, ylim = c(-4,4));lines(X[901:1000], lty = 2)
```


## Exercise 2

We will attempt to do the simulation of GARCH(1,1) ourselves.
Starting off, we may define the coefficients involved:
```{r}
sigma <- 0:1000
alpha0 <- 10^(-6)
alpha1 <- 0.9
beta1 <- 0.1 
n <- 10^3
Z <- rnorm(n+1)
X <- 0:1000
```

### a)
We may then employ the main simulation
```{r}
for (i in 2:(n+1)) {
sigma[i] <- sqrt(alpha0+alpha1*(X[i-1])^2 + beta1*(sigma[i-1])^2)
X[i] <- sigma[i]*Z[i]
}
ts.plot(sigma)
ts.plot(X)
```

### b)

As we for iid standard normal noise $\lrp{Z_t}$ have $X_{t+1} | X_t, X_{t-1}, \ldots \dnd{0}{\sigma_t^2}$
we may calculate $95\%$ and $99\%$ conditional forecast intervals based on `sigma` from a) as well as plot these, with the $95\%$ interval in red, and the $99\%$ interval in blue.
```{r}
q95 <- qnorm(0.975)
q99 <- qnorm(0.995)
condpred95U <- 0+q95*sqrt(sigma[-1]/n)
condpred95L <- 0-q95*sqrt(sigma[-1]/n)
condpred99U <- 0+q99*sqrt(sigma[-1]/n)
condpred99L <- 0-q99*sqrt(sigma[-1]/n)
sti <- 1
sli <- 1000
ts.plot(X[sti:sli]);lines(condpred95U[sti:sli], lty = 2, col = "red");lines(condpred95L[sti:sli], lty = 2, col = "red");lines(condpred99U[sti:sli], lty = 2, col = "blue");lines(condpred99L[sti:sli], lty = 2, col = "blue")
```

### c)

We may reuse the initialisation above, and start the simulation of the ARCH(1) and of the $Y_t$'s
```{r}
XARCH <- 1:1000
sigmaARCH <- 1:1000
alpha1ARCH <- 0.5
sigmaARCH[1] <- alpha0+alpha1ARCH*0
XARCH[1] <- sigmaARCH[1]*Z[1]
for (i in 2:n) {
  sigmaARCH[i] <- sqrt(alpha0+alpha1ARCH*(XARCH[i-1])^2)
  XARCH[i] <- sigmaARCH[i]*Z[i]
}
(estX0Squared <- gammaf(XARCH, 0))
YAR <- XARCH[-1]^2-estX0Squared
ts.plot(YAR)
```

We will estimate $\alpha_1$ from data, akin to how it was done in problem 1:
```{r}
(phihYAR <- gammaf(YAR,1)/gammaf(YAR,0))
```
which is fairly close to the sought after $0.5.$
Repeating the simulation and estimation 100 more times, we will now have to simulate new Z's;
```{r}
phihYARv <- 1:100
for (j in 1:100) {
  Z <- rnorm(n)
  XARCH <- 1:1000
  sigmaARCH <- 1:1000
  sigmaARCH[1] <- alpha0+alpha1ARCH*0
  XARCH[1] <- sigmaARCH[1]*Z[1]
  for (i in 2:n) {
  sigmaARCH[i] <- sqrt(alpha0+alpha1ARCH*(XARCH[i-1])^2)
  XARCH[i] <- sigmaARCH[i]*Z[i]
}
  estX0Squared <- gammaf(XARCH, 0)
  YAR <- XARCH[-1]^2-estX0Squared
  phihYARv[j] <- gammaf(YAR,1)/gammaf(YAR,0)
}
boxplot(phihYARv)
```
We see that the parameter is seemingly being underestimated.

### d)

Note that with the coefficients from a) with $\alpha_1=0.9,\,\beta_1=0.1$ that for $Z_i\dnd{0}{1}$ for $i=1,\ldots,n$ we have for $\kappa = 2$:
$$
E\lrs{\lrp{\alpha_1Z_0^2+\beta_1}^{\frac{\kappa}{2}}}=E\lrs{\lrp{0.9Z_0^2+0.1}}=0.9EZ_0^2+0.1 = 1.
$$

### e)

We will do the simulation of the $\sigma_t$'s from the model in a)
```{r}
n2e <- 10^4
Z2e <- rnorm(n2e+1)
X2e <- 0:n2e
sigma2e <- 0:n2e
for (i in 2:(n2e+1)) {
  sigma2e[i] <- sqrt(alpha0+alpha1*(X2e[i-1])^2 + beta1*(sigma2e[i-1])^2)
  X2e[i] <- sigma2e[i]*Z2e[i]
}
sigma2e <- sigma2e[-1]
```

We may then prepare to calculate and plot the Hill estimators, by creating the following functions:
```{r}
Hill <- function(Y,k) {
   n <- length(Y)
   Y <- sort(Y)
   kapk <- 0
   for (i in 1:k) {
      tempi <- log(Y[n-i+1]/(Y[n-k]))
      kapk <- kapk + tempi
   }
   1/(1/k*kapk)
}
HillVec <- function(Y,range) {
  n <- length(Y)
  Y <- sort(Y)
  kapkVec <- length(range)
  kmin <- min(range)
  for (k in range) {
    kapkVec[k-kmin+1] <- Hill(Y,k)
  }
  kapkVec
}
HillVecPlot <- function(Y, range) {
  kapkVec <- HillVec(Y,range)
  ggplot() + geom_point(mapping = aes(x=range, y=kapkVec)) + labs(x="k", y="Kappank")
}
```

We may thus plot:
```{r}
kRange <- 50:500
HillVecPlot(sigma2e, kRange) + geom_hline(yintercept = 2, colour = "red", lty = 2) + ylim(1.5,3.25)
```


<!-- Kappank <- Kappank0 -->
<!-- for (k in 50:500) { -->
<!--   Kappank[k-49] <- Hill(sigma2e,k) -->
<!-- } -->

<!-- ggplot() + geom_point(mapping = aes(x=Kappank0, y=Kappank)) + geom_hline(yintercept = 2, colour = "red", lty = 2) + ylim(1.5,3.25) + labs(x="k") -->
From the plot we see a long run of 'stability' from $k=300$ to $k=500$ at approximately $\kappa_{n}^{\lrp{k}} = 2$ in agreement with $\kappa=2.$

### f)

We may import S&P 500 Data, filter for year after 2000, create a returns column, and choosing to remove `NA` rows.
```{r}
Data <- read_csv("Data.csv",col_types =
                       cols(col_date(),
                            col_double(),
                            col_double(),
                            col_double(),
                            col_double(),
                            col_double(),
                            col_integer())) %>% filter(year(Date)>=2000) %>%  mutate(Returns = (Close - lag(Close))/lag(Close)) %>% drop_na()
head(Data, 10)
Returnvals <- Data[,8]
```

We may subset the positive and negative returns of the data, and provide further setup
```{r}
posReturnsSORTED <- c(Returnvals %>% filter(Returns>0) %>% arrange(Returns))[[1]]
negReturnsSORTED <- c(Returnvals %>% filter(Returns<0) %>% mutate(Returns = Returns * (-1)) %>% arrange(Returns))[[1]]
kPosRetRange <- 10:(floor(length(posReturnsSORTED)/10))
kNegRetRange <- 10:(floor(length(negReturnsSORTED)/10))
```
Using the previously built `HillVecPlot` function, we may thus generate the Hill estimates, and plot them:
```{r}
p0 <- HillVecPlot(posReturnsSORTED, kPosRetRange) + labs(y = "Kappank for Pos Ret")
p1 <- HillVecPlot(negReturnsSORTED, kNegRetRange) + labs(y = "Kappank for Neg Ret")
grid.arrange(p0,p1, nrow = 2)
```

We note that both seem to stabilise around $\kappa_n^{\lrp{k}}=3.$ 

